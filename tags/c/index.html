<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><title>Tag: c++ - TsaiHao&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TsaiHao&#039;s Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TsaiHao&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="TsaiHao&#039;s Blog"><meta property="og:url" content="https://tsaihao.github.io/"><meta property="og:site_name" content="TsaiHao&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://tsaihao.github.io/img/og_image.png"><meta property="article:author" content="Tsai Hao"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tsaihao.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tsaihao.github.io"},"headline":"TsaiHao's Blog","image":["https://tsaihao.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tsai Hao"},"publisher":{"@type":"Organization","name":"TsaiHao's Blog","logo":{"@type":"ImageObject","url":"https://tsaihao.github.io/misc/osprey.png"}},"description":""}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/misc/osprey.png" alt="TsaiHao&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">c++</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-04T18:08:01.000Z" title="12/4/2022, 6:08:01 PM">2022-12-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-12-05T15:55:45.838Z" title="12/5/2022, 3:55:45 PM">2022-12-05</time></span><span class="level-item"><a class="link-muted" href="/categories/blog/">blog</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/implementation_of_libcxx_any/">implementation of std::any in libc++</a></h1><div class="content"><h1 id="What-Is-std-any"><a href="#What-Is-std-any" class="headerlink" title="What Is std::any"></a>What Is <code>std::any</code></h1><p><code>std::any</code> is a new feature that comes with C++ 17 standard. It’s kind of <code>void*</code> with type-safety, supporting copy&#x2F;move&#x2F;store&#x2F;get, etc. Some basic usages of it can be found here: <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/any">std::any - cppreference</a></p>
<p>Understanding how <code>std::any</code> is implemented can be gainful, for it taking advantage of many c++ skills, especially templates.</p>
<h1 id="Implementation-of-std-any"><a href="#Implementation-of-std-any" class="headerlink" title="Implementation of std::any"></a>Implementation of <code>std::any</code></h1><p>The source code referred to below is <any> of llvm’s libcxx library, revision: <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/eb7d16ea25649909373e324e6ebf36774cabdbfa/libcxx/include/any">any - libcxx</a>.</p>
<h2 id="Class-Layout"><a href="#Class-Layout" class="headerlink" title="Class Layout"></a>Class Layout</h2><p><code>std::any</code> has two data members:</p>
<ol>
<li><p><code>__h_: _HandleFunPtr</code>, it’s a function pointer that points to a static function, as well as the entry of data manipulation including constructing&#x2F;destroying&#x2F;copying&#x2F;access, etc. Prototype of the function is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******</span></span><br><span class="line"><span class="comment">* arg1: Enum, kind of the manipulation, (_Destroy, _Copy, _Move, _Get, _TypeInfo)</span></span><br><span class="line"><span class="comment">* arg2: Caller&#x27;s &quot;this&quot; pointer</span></span><br><span class="line"><span class="comment">* arg3: Destination any, used in copy, move</span></span><br><span class="line"><span class="comment">* arg4: Runtime type info, always nullptr if rtti is disabled</span></span><br><span class="line"><span class="comment">* arg5: Fallback type info, described in next chapter</span></span><br><span class="line"><span class="comment">*******/</span></span><br><span class="line"><span class="keyword">using</span> _HandleFuncPtr =  <span class="type">void</span>* (*)(_Action, any <span class="type">const</span> *, any *, <span class="type">const</span> type_info *,</span><br><span class="line">                                        <span class="type">const</span> <span class="type">void</span>* __fallback_info);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__s_: _Storage</code>, stores pointer to managing data. It’s declared as a union for separately handling large and small objects.</p>
</li>
</ol>
<p>In conclusion, <code>std::any</code> is basically equal to an aggregate of a data block and a predefined manipulation function, which proves the famous saying <strong>Algorithms + Data Structures &#x3D; Programs</strong> to some extent.</p>
<h2 id="Skills-of-Implementation"><a href="#Skills-of-Implementation" class="headerlink" title="Skills of Implementation"></a>Skills of Implementation</h2><h3 id="Small-objects-optimization"><a href="#Small-objects-optimization" class="headerlink" title="Small objects optimization"></a>Small objects optimization</h3><blockquote>
<p>Implementations are encouraged to avoid dynamic allocations for small objects.    – cpp refrence</p>
</blockquote>
<p>The data pointer <code>__s_</code> is not a <code>void*</code> but privately declared as a such union:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _Buffer = <span class="type">aligned_storage_t</span>&lt;<span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">void</span>*), alignment_of&lt;<span class="type">void</span>*&gt;::value&gt;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">_Storage</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> _Storage() : __ptr(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="type">void</span> *  __ptr;</span><br><span class="line">    __any_imp::_Buffer __buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In a 64-bit machine, <code>_Storage</code> occupies 24 bytes. <code>__buf</code> is equally a <code>void*</code>, used when the contained object is no larger than 24 bytes. Utilizing the benefits of stack memory, constructing or copying these small objects could be more effective. Larger objects, on the other hand, have to be stored on heap memory and allocated dynamically in runtime.</p>
<p>“24 bytes” is a curated threshold that is exactly the size of <code>std::vector</code> &#x2F;<code>std::string</code> and many other STL containers in libcxx. This fact means <code>std::any</code> can manage these common objects faster, though the memory inside them could still be dynamic.</p>
<p>A similar memory optimization technology is also applied on <code>std::string</code>, but subtler. I will introduce it in the future.</p>
<h3 id="In-place-Construct"><a href="#In-place-Construct" class="headerlink" title="In-place Construct"></a>In-place Construct</h3><p>When a <code>std::any</code> object is copied, the object managed by it is also copied. It’s pretty straight yet important, simply <code>memcpy</code> is not enough because some classes have essential things to do, such as <code>std::shared_ptr</code>. <code>std::any</code>s copy object with its own copy constructor through allocator. It also applies to move construction.</p>
<p>But what about the constructor itself? Like <code>emplace_back</code> for <code>std::vector</code>, <code>std::any</code> also has an emplace-like constructor, in which the object is directly constructed on <code>__buf</code> instead of constructing a temporary object and then moving it.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::any <span class="title">a</span><span class="params">(std::in_place_type&lt;std::string&gt;, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::any <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>By inspecting these 2 variables in a debugger, we can acknowledge that <code>std::in_place_type&lt;std::string&gt;</code> has two folder meanings, it tells <code>std::any</code> constructing a <code>std::string</code> instead of a <code>const char*</code> and constructing it directly.</p>
<h3 id="Type-to-int-mapping"><a href="#Type-to-int-mapping" class="headerlink" title="Type to int mapping"></a>Type to int mapping</h3><p>Obviously, <code>std::any</code> is not a template class itself, but it can throw exceptions when casting it to a different static type even if RTTI(run-time type info) is disabled. The secret of this type-safety is a mapping from type to an integer.</p>
<p>On line 162 of <code>any.h</code>, a type-unique template struct is defined as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_typeinfo</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> __id = <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get type id if rtti is disabled</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">void</span>* __get_fallback_typeid() &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;__unique_typeinfo&lt;<span class="type">remove_cv_t</span>&lt;<span class="type">remove_reference_t</span>&lt;_Tp&gt;&gt;&gt;::__id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The static member <code>__id</code> of <code>__unique_typeinfo</code> is always equal to 0 but is a unique instance corresponding to type <code>__Tp</code> due to template specialization. Based on this, <code>std::any</code> gets the address of <code>__id</code> as a fallback type id if RTTI is disabled (compiling with flag <code>-fno-rtti</code>).</p>
<h1 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h1><p>In conclusion, the best practices of <code>std::any</code> include:</p>
<ul>
<li>To avoid unnecessary copying, use <code>std::make_any</code> or <code>std::in_place_type</code> to construct.</li>
<li>Pass <code>std::any</code> by reference if possible.</li>
<li>Use pointer version <code>std::any_cast&lt;T&gt;(&amp;a)</code> to avoid copying large objects.</li>
<li>Let custom objects conform to <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rule of three&#x2F;five&#x2F;zero</a> if managed by <code>std::any</code>.</li>
</ul>
<h1 id="Formatting-of-std-any-in-LLDB"><a href="#Formatting-of-std-any-in-LLDB" class="headerlink" title="Formatting of std::any in LLDB"></a>Formatting of <code>std::any</code> in LLDB</h1><p>Both belonging to Project LLVM, LLDB does not provide a formatted display of <code>std::any</code> of libcxx (while GDB does with libstdc++). Printing <code>std::any</code> in LLDB CLI will get:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line">Process 76235 stopped</span><br><span class="line">* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step over</span><br><span class="line">    frame #0: 0x0000000100003a3c Play`main at main.cpp:17:5</span><br><span class="line">   14          int main() &#123;</span><br><span class="line">   15              std::any a = 1;</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">16              <span class="built_in">return</span> 0;</span></span><br><span class="line">   17          &#125;</span><br><span class="line">(lldb) fr v a</span><br><span class="line">(std::any) $0 = &#123;</span><br><span class="line">  __h = 0x0000000100003d2c (Play`std::__1::__any_imp::_SmallHandler&lt;int&gt;::__handle(std::__1::__any_imp::_Action, std::__1::any const*, std::__1::any*, std::type_info const*, void const*) at any:350)</span><br><span class="line">  __s = &#123;</span><br><span class="line">    __ptr = 0x0000000000000001</span><br><span class="line">    __buf = (__lx = &quot;\U00000001\0\0\0\0\0\0\0\U00000001\0\xc1\x89FͽV\0:\0\0\U00000001&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It takes seconds to understand “a” is an int (from _SmallHandler’s type) and its value is 0x1 (from first 4 bytes of <code>__buf</code>). I write a Python script as a plugin based on LLDB API to print it more intuitively. </p>
<script src="https://gist.github.com/TsaiHao/a0abaaa7272c917d5fc00e2bdc676969.js"></script>

<h2 id="Implementation-of-plugin"><a href="#Implementation-of-plugin" class="headerlink" title="Implementation of plugin"></a>Implementation of plugin</h2><p>There are 2 functions inside this script. <code>__lldb_init_module</code> is the entry of this plugin. <code>handle_std_any</code> is the processing handle used by LLDB.</p>
<p>A tricky skill is catching the type name inside <code>_SmallHandler</code> using regex. After knowing that, we can find the object representing this type in python and then forcibly convert the pointer of buffer to it. This script should work for integers, floats, and <code>std::string</code>, but not very robust now. I will continually polish it.</p>
<blockquote>
<p>The same type-catching trick can also be employed in c++ source code. <code>__PRETTY_FUNCTION__</code> macro carries type name of a template function, so you can do some static reflections with it. A famous example is <a target="_blank" rel="noopener" href="https://github.com/Neargye/magic_enum">Magic Enum</a>.</p>
</blockquote>
<p>Another noticeable thing is that public classes of libcxx need special treatment because they have an inline namespace <code>__1</code>.</p>
</div></article></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/misc/osprey.png" alt="TsaiHao&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Tsai Hao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>